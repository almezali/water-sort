<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Sort Puzzle</title>
    <style>
        :root {
            --primary-color: #4287f5;
            --secondary-color: #505050;
            --accent-color: #ff9800;
            --error-color: #f44336;
            --highlight-color: rgba(255, 255, 255, 0.35);
            --container-bg: rgba(255, 255, 255, 0.85);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(45deg, #1a2a6c 0%, #b21f1f 50%, #fdbb2d 100%);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            color: #333;
            padding: 20px;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            background: var(--container-bg);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            width: min(95%, 800px);
            margin: 0 auto;
        }

        h1 {
            font-size: 32px;
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .top-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.12);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .game-button {
            padding: 8px 15px;
            font-size: 14px;
            font-weight: 700;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
        }

        .game-button:hover {
            transform: scale(1.05);
            filter: brightness(1.15);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        #startGame {
            background-color: var(--primary-color);
            min-width: 120px;
        }

        #newGame {
            background-color: var(--secondary-color);
            min-width: 120px;
        }

        #hintButton {
            background-color: #ff9800;
            min-width: 120px;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 20px;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.15) 100%);
            border-radius: 15px;
            font-size: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            flex-wrap: wrap;
            gap: 10px;
        }

        .stat-box {
            text-align: center;
            flex: 1;
            min-width: 100px;
            padding: 5px;
        }

        .stat-box p {
            font-size: 14px;
            font-weight: 500;
            color: #333;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .stat-box h3 {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-color);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 20px 0;
        }

        .board {
            min-height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .board-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 15px;
            padding: 10px 0;
            transition: all 0.5s ease;
        }

        .bottle {
            width: 60px;
            height: 180px;
            border: 3px solid var(--primary-color);
            border-radius: 0 0 15px 15px;
            position: relative;
            overflow: hidden;
            display: inline-block;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease;
        }

        .bottle::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 10px;
            background-color: var(--primary-color);
            border-radius: 10px 10px 0 0;
        }

        .bottle:hover {
            transform: translateY(-5px);
        }

        .bottle.selected {
            border-color: var(--accent-color);
            box-shadow: 0 0 15px var(--accent-color);
            transform: translateY(-10px) scale(1.05);
        }

        .liquid-segment {
            height: 45px; /* Each segment is 25% of the bottle height */
            position: absolute;
            bottom: 0;
            width: 100%;
            transition: all 0.5s ease;
        }

        .color-1 { background-color: #ff416c; background-image: linear-gradient(to bottom, #ff416c, #ff4b2b); }
        .color-2 { background-color: #00c853; background-image: linear-gradient(to bottom, #00c853, #009624); }
        .color-3 { background-color: #2979ff; background-image: linear-gradient(to bottom, #2979ff, #1565c0); }
        .color-4 { background-color: #aa00ff; background-image: linear-gradient(to bottom, #aa00ff, #7200ca); }
        .color-5 { background-color: #ffab00; background-image: linear-gradient(to bottom, #ffab00, #ff6d00); }
        .color-6 { background-color: #00bcd4; background-image: linear-gradient(to bottom, #00bcd4, #0097a7); }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            color: #333;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            transform: scale(0.9);
            animation: modalShow 0.3s forwards;
        }

        @keyframes modalShow {
            to { transform: scale(1); }
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .modal-content p {
            margin-bottom: 25px;
            font-size: 18px;
            color: #34495e;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .modal-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        #newGameBtn {
            background-color: var(--primary-color);
            color: white;
        }

        #closeModalBtn {
            background-color: #e74c3c;
            color: white;
        }

        .win-animation {
            animation: winEffect 1s ease-in-out;
        }

        @keyframes winEffect {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); filter: brightness(1.5); }
            100% { transform: scale(1); }
        }

        .win-background {
            animation: winBackground 1.5s;
        }

        @keyframes winBackground {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
            100% { filter: brightness(1); }
        }

        .level-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .level-button {
            padding: 5px 15px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid var(--primary-color);
            border-radius: 20px;
            color: #333;
            cursor: pointer;
            transition: all 0.3s;
        }

        .level-button:hover, .level-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        .moves-counter {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0;
            color: #333;
        }

        .hint-highlight {
            animation: hintPulse 1.5s infinite;
        }

        @keyframes hintPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 152, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0); }
        }

        @keyframes pourAnimation {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(-60px) scale(0.9); opacity: 0.8; }
            100% { transform: translateY(-120px) scale(0.7); opacity: 0; }
        }

        @keyframes receiveAnimation {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        .pouring {
            animation: pourAnimation 0.5s forwards;
        }

        .receiving {
            animation: receiveAnimation 0.5s forwards;
        }

        .score-container {
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.3) 100%);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }

        .score-item {
            text-align: center;
            flex: 1;
            min-width: 100px;
            position: relative;
        }

        .score-item h3 {
            font-size: 22px;
            color: var(--primary-color);
            margin: 5px 0;
        }

        .score-value {
            font-size: 18px;
            font-weight: bold;
            color: var(--accent-color);
        }

        .points-animation {
            animation: pointsUp 1s forwards;
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: bold;
            color: #28a745;
            opacity: 0;
        }

        @keyframes pointsUp {
            0% { opacity: 0; top: 0; }
            50% { opacity: 1; top: -20px; }
            100% { opacity: 0; top: -40px; }
        }

        .level-progress {
            height: 10px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.5s ease;
        }

        /* تأثير انسكاب السائل */
        .liquid-drop {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50% 50% 5px 5px;
            z-index: 100;
            filter: drop-shadow(0 3px 5px rgba(0,0,0,0.2));
            transition: all 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        /* تأثير الانفجار عند الفوز */
        .bottle.completed {
            animation: bottleComplete 0.8s ease-out;
        }

        @keyframes bottleComplete {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.15); filter: brightness(1.3); }
            100% { transform: scale(1); filter: brightness(1); }
        }

        /* تأثير عند تكملة أنبوب بلون واحد */
        @keyframes colorComplete {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
            100% { filter: brightness(1); }
        }

        .color-complete {
            animation: colorComplete 1s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Water Sort Puzzle</h1>
        
        <div class="controls-container">
            <div class="top-controls">
                <div class="control-group">
                    <button id="startGame" class="game-button">Start Game</button>
                    <button id="newGame" class="game-button">New Game</button>
                    <button id="hintButton" class="game-button">Hint</button>
                </div>
            </div>
            
            <div class="score-container">
                <div class="score-item">
                    <p>Level</p>
                    <h3 id="currentLevel">Easy</h3>
                    <div class="level-progress">
                        <div id="levelProgressBar" class="progress-bar"></div>
                    </div>
                </div>
                <div class="score-item">
                    <p>Score</p>
                    <h3 id="currentScore">0</h3>
                </div>
                <div class="score-item">
                    <p>High Score</p>
                    <h3 id="highScore">0</h3>
                </div>
            </div>
            
            <div class="level-selector">
                <div class="level-button active" data-level="easy">Easy</div>
                <div class="level-button" data-level="medium">Medium</div>
                <div class="level-button" data-level="hard">Hard</div>
            </div>
            
            <div class="moves-counter">Moves: <span id="moveCount">0</span></div>
        </div>

        <div class="game-area">
            <div id="gameBoard" class="board">
                <div class="board-container" id="boardContainer">
                    <!-- Bottles will be generated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <div id="gameModal" class="modal">
        <div class="modal-content">
            <h2>Game Result</h2>
            <p id="modalMessage"></p>
            <div class="modal-buttons">
                <button id="newGameBtn" class="modal-button">New Game</button>
                <button id="closeModalBtn" class="modal-button">Close</button>
            </div>
        </div>
    </div>

    <script>
        class WaterSortPuzzle {
            constructor() {
                this.selectedBottle = null;
                this.moves = 0;
                this.gameStarted = false;
                this.currentLevel = 'easy';
                this.bottles = [];
                this.score = 0;
                this.highScores = {
                    easy: 0,
                    medium: 0,
                    hard: 0
                };
                this.levelProgresses = {
                    easy: 0,
                    medium: 0,
                    hard: 0
                };
                this.colors = [
                    '#FF5733', // color-1
                    '#33FF57', // color-2
                    '#3357FF', // color-3
                    '#FF33A1', // color-4
                    '#FFC300', // color-5
                    '#DAF7A6'  // color-6
                ];
                
                // Load high scores from local storage if available
                this.loadHighScores();
                
                this.setupEventListeners();
                this.initializeGame();
            }
            
            loadHighScores() {
                const savedScores = localStorage.getItem('waterSortHighScores');
                if (savedScores) {
                    this.highScores = JSON.parse(savedScores);
                    this.updateHighScoreDisplay();
                }
                
                const savedProgress = localStorage.getItem('waterSortLevelProgress');
                if (savedProgress) {
                    this.levelProgresses = JSON.parse(savedProgress);
                    this.updateProgressDisplay();
                }
            }
            
            saveHighScores() {
                localStorage.setItem('waterSortHighScores', JSON.stringify(this.highScores));
                localStorage.setItem('waterSortLevelProgress', JSON.stringify(this.levelProgresses));
            }
            
            setupEventListeners() {
                document.getElementById('startGame').addEventListener('click', () => this.startGame());
                document.getElementById('newGame').addEventListener('click', () => this.newGame());
                document.getElementById('hintButton').addEventListener('click', () => this.showHint());
                
                document.querySelectorAll('.level-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        document.querySelectorAll('.level-button').forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                        this.setLevel(e.target.dataset.level);
                    });
                });
                
                document.getElementById('newGameBtn').addEventListener('click', () => {
                    this.newGame();
                    document.getElementById('gameModal').style.display = 'none';
                });
                
                document.getElementById('closeModalBtn').addEventListener('click', () => {
                    document.getElementById('gameModal').style.display = 'none';
                });
            }
            
            initializeGame() {
                const boardContainer = document.getElementById('boardContainer');
                boardContainer.innerHTML = '';
                
                // Determine number of bottles and colors based on level
                let numBottles, numColors;
                switch(this.currentLevel) {
                    case 'easy':
                        numBottles = 5; // 4 color bottles + 1 empty
                        numColors = 3;
                        break;
                    case 'medium':
                        numBottles = 7; // 5 color bottles + 2 empty
                        numColors = 4;
                        break;
                    case 'hard':
                        numBottles = 9; // 6 color bottles + 3 empty
                        numColors = 5;
                        break;
                    default:
                        numBottles = 5;
                        numColors = 3;
                }
                
                // Create bottles array
                this.bottles = [];
                
                // Create color segments
                let colorSegments = [];
                for (let i = 0; i < numColors; i++) {
                    // Each color appears 4 times (to fill a bottle)
                    for (let j = 0; j < 4; j++) {
                        colorSegments.push(i);
                    }
                }
                
                // Shuffle color segments
                this.shuffleArray(colorSegments);
                
                // Create bottles with color segments
                for (let i = 0; i < numBottles; i++) {
                    const bottle = document.createElement('div');
                    bottle.className = 'bottle';
                    bottle.id = `bottle-${i}`;
                    bottle.addEventListener('click', () => this.handleBottleClick(i));
                    
                    // Add bottle to DOM
                    boardContainer.appendChild(bottle);
                    
                    // Initialize bottle data
                    let bottleData = [];
                    
                    // Fill bottles with color segments (except for empty bottles)
                    if (i < numBottles - (numBottles - numColors)) {
                        for (let j = 0; j < 4; j++) {
                            if (colorSegments.length > 0) {
                                const colorIndex = colorSegments.pop();
                                bottleData.push(colorIndex);
                                
                                // Create visual segment
                                const segment = document.createElement('div');
                                segment.className = `liquid-segment color-${colorIndex + 1}`;
                                segment.style.bottom = `${j * 45}px`; // Position segments
                                bottle.appendChild(segment);
                            }
                        }
                    }
                    
                    this.bottles.push(bottleData);
                }
                
                // Reset game state
                this.selectedBottle = null;
                this.moves = 0;
                this.gameStarted = false;
                document.getElementById('moveCount').textContent = this.moves;
            }
            
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
            
            startGame() {
                if (!this.gameStarted) {
                    this.gameStarted = true;
                    document.getElementById('startGame').textContent = 'Game Started';
                }
            }
            
            newGame() {
                this.initializeGame();
                document.getElementById('startGame').textContent = 'Start Game';
            }
            
            handleBottleClick(bottleIndex) {
                if (!this.gameStarted) {
                    alert('Please start the game first!');
                    return;
                }
                
                // Remove any hint highlights
                document.querySelectorAll('.hint-highlight').forEach(el => {
                    el.classList.remove('hint-highlight');
                });
                
                const bottle = document.getElementById(`bottle-${bottleIndex}`);
                
                if (this.selectedBottle === null) {
                    // Select this bottle if it's not empty
                    if (this.bottles[bottleIndex].length > 0) {
                        this.selectedBottle = bottleIndex;
                        bottle.classList.add('selected');
                    }
                } else {
                    // Try to pour from selected bottle to this one
                    if (this.selectedBottle !== bottleIndex) {
                        if (this.pourLiquid(this.selectedBottle, bottleIndex)) {
                            this.moves++;
                            document.getElementById('moveCount').textContent = this.moves;
                            
                            // Check for win condition
                            if (this.checkWinCondition()) {
                                this.showWinModal();
                            }
                        }
                    }
                    
                    // Deselect the bottle
                    document.getElementById(`bottle-${this.selectedBottle}`).classList.remove('selected');
                    this.selectedBottle = null;
                }
            }
            
            pourLiquid(fromIndex, toIndex) {
                const fromBottle = this.bottles[fromIndex];
                const toBottle = this.bottles[toIndex];
                
                // Check if the move is valid
                if (fromBottle.length === 0) return false; // Source bottle is empty
                if (toBottle.length === 4) return false; // Destination bottle is full
                
                const colorToPour = fromBottle[fromBottle.length - 1];
                
                // Check if we can pour into the destination bottle
                if (toBottle.length > 0 && toBottle[toBottle.length - 1] !== colorToPour) {
                    return false; // Can't mix different colors
                }
                
                // Find how many segments of the same color we can pour
                let segmentsToPour = 0;
                for (let i = fromBottle.length - 1; i >= 0; i--) {
                    if (fromBottle[i] === colorToPour) {
                        segmentsToPour++;
                    } else {
                        break;
                    }
                }
                
                // Limit by available space in destination bottle
                segmentsToPour = Math.min(segmentsToPour, 4 - toBottle.length);
                
                if (segmentsToPour === 0) return false;
                
                // Add pouring animation
                this.animatePour(fromIndex, toIndex, segmentsToPour, colorToPour);
                
                // Update the score based on segments poured
                this.updateScore(segmentsToPour);
                
                return true;
            }
            
            animatePour(fromIndex, toIndex, segmentsToPour, colorToPour) {
                const fromBottle = document.getElementById(`bottle-${fromIndex}`);
                const toBottle = document.getElementById(`bottle-${toIndex}`);
                
                // Create animation effect
                fromBottle.classList.add('pouring');
                toBottle.classList.add('receiving');
                
                // Get positions for animation
                const fromRect = fromBottle.getBoundingClientRect();
                const toRect = toBottle.getBoundingClientRect();
                const boardRect = document.getElementById('boardContainer').getBoundingClientRect();
                
                // Calculate path coordinates
                const startX = fromRect.left + fromRect.width/2 - boardRect.left;
                const startY = fromRect.top - boardRect.top;
                const endX = toRect.left + toRect.width/2 - boardRect.left;
                const endY = toRect.top - boardRect.top;
                
                // Create liquid path points (arc path)
                const controlX = (startX + endX) / 2; 
                const controlY = Math.min(startY, endY) - 50; // Arc height
                
                // For each segment to pour, create a dropping animation
                for (let i = 0; i < segmentsToPour; i++) {
                    const drop = document.createElement('div');
                    drop.className = `liquid-drop color-${colorToPour + 1}`;
                    document.getElementById('boardContainer').appendChild(drop);
                    
                    // Set initial position
                    drop.style.left = `${startX - 10}px`;
                    drop.style.top = `${startY}px`;
                    
                    // Delay each drop slightly for cascading effect
                    setTimeout(() => {
                        // Create animation function to follow arc path
                        const animateArc = (progress) => {
                            // Parametric equation for quadratic bezier curve
                            const x = Math.pow(1-progress, 2) * startX + 
                                      2 * (1-progress) * progress * controlX + 
                                      Math.pow(progress, 2) * endX;
                            
                            const y = Math.pow(1-progress, 2) * startY + 
                                      2 * (1-progress) * progress * controlY + 
                                      Math.pow(progress, 2) * endY;
                            
                            drop.style.left = `${x - 10}px`;
                            drop.style.top = `${y}px`;
                            
                            // Scale and rotate for dynamic effect
                            const scale = 1 - (progress * 0.3);
                            const rotate = progress * 360;
                            drop.style.transform = `scale(${scale}) rotate(${rotate}deg)`;
                            
                            if (progress >= 1) {
                                // Animation complete, remove drop
                                setTimeout(() => drop.remove(), 100);
                                return;
                            }
                            
                            requestAnimationFrame(() => animateArc(progress + 0.02));
                        };
                        
                        // Start the animation
                        requestAnimationFrame(() => animateArc(0));
                    }, 120 * i);
                }
                
                // Play pouring sound
                this.playSound('pour');
                
                // After animation completes, update the bottles
                setTimeout(() => {
                    // Pour the liquid
                    for (let i = 0; i < segmentsToPour; i++) {
                        const color = this.bottles[fromIndex].pop();
                        this.bottles[toIndex].push(color);
                    }
                    
                    // Update the visual representation
                    this.updateBottleVisuals(fromIndex);
                    this.updateBottleVisuals(toIndex);
                    
                    // Remove animation classes
                    fromBottle.classList.remove('pouring');
                    toBottle.classList.remove('receiving');
                    
                    // Add completion animation if bottle is complete
                    if (this.isBottleComplete(toIndex)) {
                        toBottle.classList.add('completed');
                        this.playSound('complete');
                        setTimeout(() => toBottle.classList.remove('completed'), 800);
                    }
                    
                    this.moves++;
                    document.getElementById('moveCount').textContent = this.moves;
                    
                    // Check for win condition
                    if (this.checkWinCondition()) {
                        this.handleLevelComplete();
                    }
                    
                }, 700);
            }
            
            updateScore(segmentsPoured) {
                // Base points for each segment
                const basePoints = 10;
                
                // Points multiplier based on level
                let multiplier = 1;
                if (this.currentLevel === 'medium') multiplier = 1.5;
                if (this.currentLevel === 'hard') multiplier = 2;
                
                // Bonus for multiple segments at once
                const bonus = segmentsPoured > 1 ? segmentsPoured * 5 : 0;
                
                // Calculate total points
                const pointsEarned = Math.round((basePoints * segmentsPoured * multiplier) + bonus);
                
                // Add points to score
                this.score += pointsEarned;
                
                // Show floating points animation
                this.showPointsAnimation(pointsEarned);
                
                // Update score display
                document.getElementById('currentScore').textContent = this.score;
            }
            
            showPointsAnimation(points) {
                const pointsElement = document.createElement('div');
                pointsElement.className = 'points-animation';
                pointsElement.textContent = `+${points}`;
                
                // تعديل لون النقاط حسب قيمتها
                if (points > 30) {
                    pointsElement.style.color = '#f44336'; // أحمر للنقاط العالية
                    pointsElement.style.fontSize = '24px';
                } else if (points > 20) {
                    pointsElement.style.color = '#ff9800'; // برتقالي للنقاط المتوسطة
                    pointsElement.style.fontSize = '22px';
                } else {
                    pointsElement.style.color = '#4caf50'; // أخضر للنقاط العادية
                }
                
                const scoreItem = document.querySelector('.score-item:nth-child(2)');
                scoreItem.appendChild(pointsElement);
                
                // إضافة تأثير حركي لتحديث النقاط
                const scoreDisplay = document.getElementById('currentScore');
                scoreDisplay.style.transform = 'scale(1.2)';
                scoreDisplay.style.color = '#ff9800';
                
                setTimeout(() => {
                    scoreDisplay.style.transition = 'all 0.5s ease';
                    scoreDisplay.style.transform = 'scale(1)';
                    scoreDisplay.style.color = '';
                }, 500);
                
                // Remove after animation completes
                setTimeout(() => {
                    pointsElement.remove();
                }, 1000);
            }
            
            handleLevelComplete() {
                // Update high score if current score is higher
                if (this.score > this.highScores[this.currentLevel]) {
                    this.highScores[this.currentLevel] = this.score;
                    this.saveHighScores();
                    this.updateHighScoreDisplay();
                }
                
                // Increase level progress
                this.levelProgresses[this.currentLevel] = Math.min(100, this.levelProgresses[this.currentLevel] + 20);
                this.saveHighScores(); // This also saves progress
                this.updateProgressDisplay();
                
                // Show win modal
                this.showWinModal();
            }
            
            updateHighScoreDisplay() {
                document.getElementById('highScore').textContent = this.highScores[this.currentLevel];
            }
            
            updateProgressDisplay() {
                document.getElementById('levelProgressBar').style.width = `${this.levelProgresses[this.currentLevel]}%`;
            }
            
            showWinModal() {
                const modal = document.getElementById('gameModal');
                const message = document.getElementById('modalMessage');
                message.innerHTML = `
                    <p>Congratulations! You solved the puzzle in ${this.moves} moves!</p>
                    <p>Score: ${this.score}</p>
                    <p>Level Progress: ${this.levelProgresses[this.currentLevel]}%</p>
                `;
                modal.style.display = 'flex';
                document.body.classList.add('win-background');
                
                setTimeout(() => {
                    document.body.classList.remove('win-background');
                }, 1500);
            }
            
            // When changing levels, update displays
            setLevel(level) {
                this.currentLevel = level;
                document.getElementById('currentLevel').textContent = 
                    level.charAt(0).toUpperCase() + level.slice(1); // Capitalize first letter
                this.updateHighScoreDisplay();
                this.updateProgressDisplay();
                this.newGame();
            }
            
            checkWinCondition() {
                // Game is won when each bottle either has 4 segments of the same color or is empty
                return this.bottles.every(bottle => {
                    if (bottle.length === 0) return true; // Empty bottle is fine
                    if (bottle.length !== 4) return false; // Partially filled bottle is not solved
                    
                    // Check if all segments are the same color
                    const firstColor = bottle[0];
                    return bottle.every(color => color === firstColor);
                });
            }
            
            showHint() {
                if (!this.gameStarted) {
                    alert('Please start the game first!');
                    return;
                }
                
                // Find a valid move
                let hintFound = false;
                
                // First, try to find a move that completes a bottle
                for (let fromIdx = 0; fromIdx < this.bottles.length; fromIdx++) {
                    const fromBottle = this.bottles[fromIdx];
                    if (fromBottle.length === 0) continue;
                    
                    const topColor = fromBottle[fromBottle.length - 1];
                    
                    // Count how many of the same color are at the top
                    let sameColorCount = 0;
                    for (let i = fromBottle.length - 1; i >= 0; i--) {
                        if (fromBottle[i] === topColor) {
                            sameColorCount++;
                        } else {
                            break;
                        }
                    }
                    
                    for (let toIdx = 0; toIdx < this.bottles.length; toIdx++) {
                        if (fromIdx === toIdx) continue;
                        
                        const toBottle = this.bottles[toIdx];
                        
                        // Check if this move would complete a bottle of the same color
                        if (toBottle.length > 0 && toBottle[0] === topColor && 
                            toBottle.every(color => color === topColor) && 
                            toBottle.length + sameColorCount === 4) {
                            
                            // Highlight the bottles
                            document.getElementById(`bottle-${fromIdx}`).classList.add('hint-highlight');
                            document.getElementById(`bottle-${toIdx}`).classList.add('hint-highlight');
                            hintFound = true;
                            return;
                        }
                    }
                }
                
                // If no completing move, find any valid move
                if (!hintFound) {
                    for (let fromIdx = 0; fromIdx < this.bottles.length; fromIdx++) {
                        const fromBottle = this.bottles[fromIdx];
                        if (fromBottle.length === 0) continue;
                        
                        const topColor = fromBottle[fromBottle.length - 1];
                        
                        for (let toIdx = 0; toIdx < this.bottles.length; toIdx++) {
                            if (fromIdx === toIdx) continue;
                            
                            const toBottle = this.bottles[toIdx];
                            
                            // Check if we can pour into this bottle
                            if (toBottle.length < 4 && (toBottle.length === 0 || toBottle[toBottle.length - 1] === topColor)) {
                                // Highlight the bottles
                                document.getElementById(`bottle-${fromIdx}`).classList.add('hint-highlight');
                                document.getElementById(`bottle-${toIdx}`).classList.add('hint-highlight');
                                return;
                            }
                        }
                    }
                }
                
                // If no hint found
                alert('No valid moves found!');
            }

            // إضافة دالة للتحقق من اكتمال الأنبوب بلون واحد
            isBottleComplete(bottleIndex) {
                const bottle = this.bottles[bottleIndex];
                if (bottle.length !== 4) return false;
                
                const firstColor = bottle[0];
                return bottle.every(color => color === firstColor);
            }

            // إضافة دالة للأصوات
            playSound(soundType) {
                // يمكن إضافة أصوات في الإصدار المستقبلي
                // ملاحظة: تحتاج لإضافة ملفات الصوت للمشروع
            }

            updateBottleVisuals(bottleIndex) {
                const bottle = document.getElementById(`bottle-${bottleIndex}`);
                bottle.innerHTML = ''; // Clear existing segments
                
                const bottleData = this.bottles[bottleIndex];
                
                // Add segments based on bottle data
                for (let i = 0; i < bottleData.length; i++) {
                    const segment = document.createElement('div');
                    segment.className = `liquid-segment color-${bottleData[i] + 1}`;
                    segment.style.bottom = `${i * 45}px`; // Position segments
                    
                    // Add subtle animation when adding new segment
                    segment.style.transform = 'scale(0.9)';
                    segment.style.opacity = '0.8';
                    
                    bottle.appendChild(segment);
                    
                    // Animate the new segment appearing
                    setTimeout(() => {
                        segment.style.transition = 'all 0.3s ease';
                        segment.style.transform = 'scale(1)';
                        segment.style.opacity = '1';
                    }, 10);
                }
                
                // Check if bottle is complete with one color
                if (this.isBottleComplete(bottleIndex)) {
                    // Add a subtle glow effect to complete bottles
                    bottle.style.boxShadow = '0 0 15px rgba(255, 255, 255, 0.7)';
                } else {
                    bottle.style.boxShadow = '';
                }
            }
        }

        // Initialize the game
        const waterSortPuzzle = new WaterSortPuzzle();
    </script>
</body>
</html>
